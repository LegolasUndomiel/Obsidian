# 1 为什么引入智能指针
- 动态内存分配存在内存泄漏、悬空指针、重复释放等问题
- 所谓“智能”是因为它可以帮助用户自动管理内存
- 实现原理是利用类封装了原始指针，类的对象实例在销毁时会调用析构函数，在析构函数中释放内存，实现自动管理内存的目的
# 2 智能指针分类
## 2.1 unique_ptr
- 独占指针所用权，不能被复制，只能移动(`std::move`)
- 适用于独占资源
- 通过new创建
- `std::make_unique<T>(args)`创建(C++14)
- `std::make_unique<T>(args)`有什么好处？
- `get()`获取指针地址
- `->`和`*`运算符重载
- 做函数参数或返回值是需要注意所有权
	- 值传递：需要使用`std::move`来转移内存所有权、参数直接传入`std::make_unique`语句，自动转换为`move`
	- 引用传递：如果设置参数为`const`则不能改变指向
	- 返回值：指向一个local object，可以用作链式函数
## 2.2 shared_ptr
- 采用 **引用计数**，多个`shared_ptr`对象可共享同一指针所用权，最后一个对象销毁时释放资源
- 存在循环引用风险，需配合`weak_ptr`使用
- `std::make_shared<T>(args)`创建，减少内存分配开销
## 2.3 weak_ptr
- 依赖`shared_ptr`，不会增加引用计数
- 解决`shared_ptr`循环引用问题
- 可通过`lock()`获取`shared_ptr`，判断对象是否有效
# 3 手动实现
- 每个shared_ptr实例指向同一个对象，所有的实例共享一个计数器
- 创建新的shared_ptr实例或拷贝shared_ptr时，计数器增加
- 当shared_ptr被销毁(析构函数)或重置(reset)时，计数器减小
- 计数器为零时，对象被自动删除，最后一个shared_ptr对象销毁时释放内存，防止内存泄漏
- 适合多线程或复杂数据结构中需要共享对象的场景

# 4 `make_shared<T>(args)`的好处
- 原始指针和智能指针存储在连续的内存块，避免额外的内存分配，只进行一次内存分配，减少malloc/free的开销，提高缓存命中率
- 减少异常安全问题，`std::shared_ptr(new T(args))`是两个独立的操作，两个new操作只要有一个出错就会崩盘
- `std::make_shared`进行原子操作，比较安全